<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title> Inside Niftys RenderDevice and how to speed it up (Part 2&#47;2) </title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1> Nifty GUI </h1>
        <h2>Your Open Source Java OpenGL GUI</h2>
        <a href="https://github.com/void256/nifty-gui" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          
          <h2>Inside Niftys RenderDevice and how to speed it up (Part 2&#47;2)</h2>
<p class="meta">01 Apr 2013</p>

<p>Welcome back to the second part of this two part mini series. Today we'll speed up the Nifty rendering process. So fasten your seat belts - it will be a long and rough ride! :)</p>

<p>In the <a href="http:&#47;&#47;nifty-gui.lessvoid.com&#47;archives&#47;505">first part<&#47;a> we've identified several problems that we'd like to fix today:</p>

<p><ul>
<li>primitive&#47;polygon submission is not optimal and requires way too many GL calls&lt;&#47;li&gt;
<li>we switch GL state very often, especially enabling&#47;disabling texturing while rendering and switching the current texture costs performance&lt;&#47;li&gt;
<li>we enable&#47;disable and change the clipping rectangle very often (eventually)&lt;&#47;li&gt;
<li>we change other states like the blend mode. Not a lot but it is still happening if you ask for it within your screen (f.i. using some effect)&lt;&#47;li&gt;<br />
&lt;&#47;ul&gt;</p>
<p>So let&#39;s tackle these issues one at a time.<br />
<a id="more"></a><a id="more-530"></a><br />
I won&#39;t go into the specific OpenGL methods too much and will concentrate more on the &quot;Nifty&quot; side of things. You can read up the OpenGL calls <a href="http:&#47;&#47;www.opengl.org&#47;sdk&#47;docs&#47;man3&#47;">elsewhere&lt;&#47;a&gt;. But the interesting part - at least for me and I hope for you as well - is to connect all the dots and combine the individual pieces to optimize Nifty.</p>
<p>So without further ado let&#39;s rock.</p>
<p><em><strong>Optimize polygon submission&lt;&#47;strong&gt;&lt;&#47;em&gt;</p>
<p>Well, that one is a no brainer since vertex arrays have been a part of the OpenGL spec since the very early OpenGL 1.1 days (1995 or so). The idea is to put all of your vertex data into an array and then give OpenGL a pointer to that array and tell it in a single call: now go and render all of them. Since I&#39;d like to keep the current LWJGL renderer compatible with legacy OpenGL (for now, be patient ^^) I&#39;ve used plain old client-side vertex arrays. This means that all of the vertex data is stored on the CPU and is only send to the GPU for rendering. This allows us to take advantage of the GL<em>QUADS rendering mode (which has been optimized away from core profile unfortunatly).</p>
<p>So for each Nifty <a href="https:&#47;&#47;github.com&#47;void256&#47;nifty-gui&#47;blob&#47;1.3&#47;nifty-core&#47;src&#47;main&#47;java&#47;de&#47;lessvoid&#47;nifty&#47;spi&#47;render&#47;RenderDevice.java">RenderDevice&lt;&#47;a&gt; render*() method (renderQuad() or renderImage()) we add four vertices to the vertex buffer representing a single quad. When Nifty later calls the endFrame() method we render all of the quads with a single glDrawElements(GL</em>QUADS) call. This way we can remove a couple of hundred individual glBegin()&#47;glEnd()&#47;glVertex() calls and GL can now take our buffer, process it in one step and render it! Much faster!</p>
<p>Great! We&#39;re done! Woohoo!</p>
<p>But wait, what do you say? We&#39;re not finished yet? What&#39;s with all of the texturing and what is with font rendering? And what if we want to render a single colored untextured quad like a Nifty panel with a plain backgroundColor? Wouldn&#39;t we have to disable texturing somehow in between all those quads in the vertex array?</p>
<p>Of course you&#39;re right - readers are always right ;) So let&#39;s continue.</p>
<p><strong>Disable texturing while rendering with a vertex array&lt;&#47;strong&gt;</p>
<p>If we would enable&#47;disable texturing all the time or switch the current texture while we&#39;re rendering our quads we would end up with individual render calls again. In the end all of our performance gains would have been lost again. So what should we do?</p>
<p>Our first trick is to let texturing enabled all the time. We&#39;ll simply submit textured quads only - all the time. To render a plain colored quad we&#39;ll reserve some pixels of a plain solid color in our texture, let&#39;s say white. If we then render a quad with texture coordinates of this white piece of the texture we would end up with a solid white quad - and this quad could really be any size we want since it doesn&#39;t really matter if we would stretch a single white pixel to the size of the screen. It would still be white :)</p>
<p>So that&#39;s great. We can render white colored quads. Yeah! But what about other colors? Ok, that&#39;s easy as well. We attach vertex colors to our vertices. To render a plain colored red quad for instance, we&#39;ll set the vertex color of each vertex to red and in the end we&#39;d have a red quad instead of a white one. And btw. this allows us to add support for linear gradients as well when we use different colors.</p>
<p>So to summarize our vertex data, here are the components we store per vertex in our array:</p>
<ul>
<li>The position of the vertex. At the moment we&#39;re only 2d so two floats should be appropriate (x and y coordinates)&lt;&#47;li&gt;
<li>The texture coordinate for the vertex (u and v, 2 floats as well)&lt;&#47;li&gt;
<li>A color for the vertex. That will add 4 more floats.&lt;&#47;li&gt;<br />
&lt;&#47;ul&gt;</p>
<p>So there is no need to disable texturing at all! If we want to render a plain colored quad we&#39;ll simply adjust the texture coordinates of that quad in our vertex array to match up with the plain colored area in our texture.</p>
<p><strong>Switch the current texture while rendering with a vertex array&lt;&#47;strong&gt;</p>
<p>Finally we&#39;ll need a way to render different textures. The solution to this is simple in theory but was a bit more involved in the end.</p>
<p>The idea is to combine all of our individual images into one big texture. The name for this optimization technique is &quot;texture atlas&quot; or &quot;texture packing&quot;. In most cases you would combine your textures into a bigger one as a pre-process using some custom tool. But for Nifty we&#39;ll need to do that dynamically. Let&#39;s enter the world of texture packing algorithms also known as bin packing.</p>
<p>Well, as it appears this topic is a huge one! There are even PhD Thesis discussing this in depth (The PhD Thesis of Andrea Lodi f.i.: <a href="http:&#47;&#47;citeseerx.ist.psu.edu&#47;viewdoc&#47;download?doi=10.1.1.98.3502&rep=rep1&type=pdf">Algorithms for Two Dimensional Bin Packing and Assignment Problems&lt;&#47;a&gt;).</p>
<p>One of the more simple algorithms and the one we&#39;ll use for now is the <a href="http:&#47;&#47;www.blackpawn.com&#47;texts&#47;lightmaps&#47;default.html">Lightmap Packing Algorithm&lt;&#47;a&gt; by <a href="http:&#47;&#47;www.blackpawn.com&#47;">Black Pawn&lt;&#47;a&gt; and the <a href="https:&#47;&#47;github.com&#47;lukaszdk&#47;texture-atlas-generator">Java port&lt;&#47;a&gt; of this algorithm done by <a href="https:&#47;&#47;github.com&#47;lukaszdk&#47;texture-atlas-generator">lukaszdk&lt;&#47;a&gt;.</p>
<p>The Java version of the <a href="https:&#47;&#47;github.com&#47;lukaszdk&#47;texture-atlas-generator">Texture Atlas Generator&lt;&#47;a&gt; is meant to be used as an executable jar that combines multiple textures into a bigger one using java.awt.image.* stuff. Not bad but for Nifty we&#39;d like to do that on the fly and we&#39;d like to separate the actual algorithm from the actual handling of the graphics. In the end the algorithm can work independently of the actual graphics data. So we&#39;ve modified his code a bit. If you&#39;re interested in the details you can find our version in the <a href="https:&#47;&#47;github.com&#47;void256&#47;nifty-gui&#47;blob&#47;1.3&#47;nifty-core&#47;src&#47;main&#47;java&#47;de&#47;lessvoid&#47;nifty&#47;batch&#47;TextureAtlasGenerator.java">TextureAtlasGenerator&lt;&#47;a&gt; class. This class can be used on its own since it is self contained and doesn&#39;t need any Nifty dependencies at all - if you ever need a similar algorithm ;)</p>
<p>So we&#39;ll start with a big texture (something like 2048x2048 pixels works very well so far) and as Nifty loads images we&#39;ll put them into this texture at positions the TextureAtlasGenerator calculates for us. And with that in place switching textures actually only means changing the texture coordinates according to the data that the TextureAtlasGenerator has generated. And voila we can keep rendering all of our quads in a single call using the same big texture! :D</p>
<p><strong>Managing image resources&lt;&#47;strong&gt;</p>
<p>The texture atlas will be filled with images for the current Nifty screen. This way all images used will be part of the texture atlas. To do that Nifty keeps track of which image belongs to which screen when it reads a XML file or when a screen is created with the Builder pattern. This tracking is done for all loaded screens and even for images that are dynamically created with Nifty.createImage().</p>
<p>In general Nifty will make sure that it uploads all images that are required for a screen when the screen is started (and gets active). Consequently when a screen ends the texture atlas is being reset to an empty one.</p>
<p>Nifty already implemented a reference counting mechanism to keep track of loaded images. This was used to prevent loading the same image multiple times and it is still being used for this purpose. However, the process of loading an image is now separated into two steps:</p>
<p>1. the actual image data is loaded into whatever image representation an implementation supports (for instance the implementation using native LWJGL will simply load an image file into a ByteBuffer) and</p>
<p>2. the loaded image data is put into the texture atlas at a position that Nifty decided when it&#39;s time for this image to be a part of the current screens texture atlas.</p>
<p>When an image is accessed dynamically while a screen is running it will be uploaded at the time of the first access. For best performance static images - or at least ones that Nifty knows about before the screen is started - should be preferred so that Nifty can upload them to the texture atlas at the time the screen starts and not while the screen is already running. Although I think you can get away with a couple of image uploads if you don&#39;t access too many new images at once.</p>
<p>All of this is required to keep only the currently active images in the texture atlas. This should work quite well for most use cases. However, it&#39;s still possible to use up all of the available space in the texture atlas. In that case Nifty will complain in the log but there will be missing images. All of the Nifty examples run well with a 2K (2048x2048) texture so far. The batch renderer provides a better rendering performance but you might want to plan for some additional tests to check if all of your images fit into the texture.</p>
<p><strong>Clipping&lt;&#47;strong&gt;</p>
<p>Nifty allows you to clip child elements to the area of it&#39;s parent element. This way only the part that intersects with the parent element will be displayed. The original Nifty renderer used glScissor() for this prior to rendering the child elements. The problem with this approach is that we can&#39;t change the size of the scissor box while rendering with vertex arrays. So what should we do?</p>
<p>Well, clipping is a somewhat simple 2d operation so we simply clip on the CPU now! The quads we will send into the vertex array will already be clipped so we don&#39;t have to change the scissor state while we&#39;re rendering :)</p>
<p><strong>Blending&lt;&#47;strong&gt;</p>
<p>Nifty renders everything with usual alpha transparency blending (glBlendFunc(GL<em>SRC</em>ALPHA, GL<em>ONE</em>MINUS<em>SRC</em>ALPHA)) but it can be changed to Multiply (glBlendFunc(GL<em>DST</em>COLOR, GL_ZERO)) if necessary for rendering special effects. However, for the optimized renderer this is a slight problem since we can&#39;t change the blending mode while rendering a vertex array. What Nifty will do now is to create a new batch when the blending mode changes. Since the Multiply blending mode is currently the only &quot;other&quot; blend mode supported and this is rarely used we&#39;ll get away with the new batch approach. Rendering a couple of batches per frame is still a lot better than rendering hundreds of individual quads with hundreds of draw calls.</p>
<p>So with blending out of the way we&#39;ve actually solved all of the problems we set out to fix! :D</p>
<p>The only thing we have to discuss is how all of this has been implemented.</p>
<p>Usually this is done by each rendering system individually like a LWJGL, JOGL or JME3 batched renderer implementation. However each of these individual implementations would solve the exact same problems outlined above. All of the batching, texture atlas management and so on. Not a very nifty solution.</p>
<p>A better approach would be to solve the managment of the batches once and then use a simplified implementation for the native implementations. And that&#39;s exactly what we did :D</p>
<p><strong>Unified batched RenderDevice implementation!&lt;&#47;strong&gt;</p>
<p>Nifty 1.3.3 will provide a default implementation of the RenderDevice interface. The <a href="https:&#47;&#47;github.com&#47;void256&#47;nifty-gui&#47;blob&#47;1.3&#47;nifty-core&#47;src&#47;main&#47;java&#47;de&#47;lessvoid&#47;nifty&#47;batch&#47;BatchRenderDevice.java">de.lessvoid.nifty.batch.BatchRenderDevice&lt;&#47;a&gt; handles all of things we&#39;ve mentioned so far including all of the texture packing logic and so on.</p>
<p>Of course there is still the need for specific implementations to connect all of this to LWJGL, JOGL or jME. But these implementations are now much simpler since they don&#39;t have to handle all of the details the original RenderDevice has to. The <a href="https:&#47;&#47;github.com&#47;void256&#47;nifty-gui&#47;blob&#47;1.3&#47;nifty-core&#47;src&#47;main&#47;java&#47;de&#47;lessvoid&#47;nifty&#47;batch&#47;spi&#47;BatchRenderBackend.java">de.lessvoid.nifty.batch.spi.BatchRenderBackend&lt;&#47;a&gt; SPI is much simpler. The BatchRenderBackend will receive quads that it should buffer in whatever way it sees fit. The LWJGL implementation fills a vertex array exactly as we&#39;ve described above. Handling the texture atlas is reduced to creating a texture and replacing subtextures.</p>
<p>Rendering fonts is also handled inside the BatchRenderDevice which means the BatchRenderBackend doesn&#39;t have to implement that. Font rendering is reduced to rendering quads as well and the font texture is simply treated as another part of the texture atlas. This has the additional benefit that font rendering looks the same no matter what rendering system you use because things like kerning, text string width calculations and so on are all happening inside of Nifty now :)</p>
<p>But wait, there is even more!</p>
<p><strong>Bonus: LWJGL OpenGL Core Profile implementation&lt;&#47;strong&gt;</p>
<p>Until this point you could not really use Nifty with modern OpenGL because the original LWJGL implementation didn&#39;t support it. With the new BatchRenderDevice a full OpenGL Core Profile implementation is now available! :D</p>
<p><strong>Shut up and <del datetime="2013-04-01T08:09:45+00:00">take my money&lt;&#47;del&gt; show me how to use it&lt;&#47;strong&gt;</p>
<p>Usage of the batched renderer is very easy. In place of your usual RenderDevice implementation you use the BatchRendererDevice when you instantiante Nifty:</p>
<pre class="brush:java">BatchRenderDevice renderDevice = new BatchRenderDevice(<br />
    put-in-batched-renderer-backend-here, &#47;&#47; BatchRenderBackend impl<br />
    2048, &#47;&#47; width of texture atlas<br />
    2048); &#47;&#47; height of texture atlas&lt;&#47;pre&gt;</p>
<p>The first parameter is an implementation of the <a href="https:&#47;&#47;github.com&#47;void256&#47;nifty-gui&#47;blob&#47;1.3&#47;nifty-core&#47;src&#47;main&#47;java&#47;de&#47;lessvoid&#47;nifty&#47;batch&#47;spi&#47;BatchRenderBackend.java">de.lessvoid.nifty.batch.spi.BatchRenderBackend&lt;&#47;a&gt; interface that connects the batched renderer to a specific OpenGL implementation. Currently the following implementations exist:</p>
<ul>
<li>LWJGL legacy batched renderer: <a href="https:&#47;&#47;github.com&#47;void256&#47;nifty-gui&#47;blob&#47;1.3&#47;nifty-renderer-lwjgl&#47;src&#47;main&#47;java&#47;de&#47;lessvoid&#47;nifty&#47;renderer&#47;lwjgl&#47;render&#47;batch&#47;LwjglBatchRenderBackend.java">de.lessvoid.nifty.renderer.lwjgl.render.batch.LwjglBatchRenderBackend&lt;&#47;a&gt;&lt;&#47;li&gt;
<li>LWJGL core profile batched renderer: <a href="https:&#47;&#47;github.com&#47;void256&#47;nifty-gui&#47;blob&#47;1.3&#47;nifty-renderer-lwjgl&#47;src&#47;main&#47;java&#47;de&#47;lessvoid&#47;nifty&#47;renderer&#47;lwjgl&#47;render&#47;batch&#47;LwjglBatchRenderBackendCoreProfile.java">de.lessvoid.nifty.renderer.lwjgl.render.batch.LwjglBatchRenderBackendCoreProfile&lt;&#47;a&gt;&lt;&#47;li&gt;
<li>jme3 batched renderer implementation: <a href="http:&#47;&#47;code.google.com&#47;p&#47;jmonkeyengine&#47;source&#47;browse&#47;trunk&#47;engine&#47;src&#47;niftygui&#47;com&#47;jme3&#47;niftygui&#47;JmeBatchRenderBackend.java">com.jme3.niftygui.JmeBatchRenderBackend&lt;&#47;a&gt;&lt;&#47;li&gt;<br />
&lt;&#47;ul&gt;</p>
<p>You&#39;ll need to use Nifty 1.3.3 or Nifty 1.4 nightly builds to have these new implementations available. For jme3 you&#39;ll need a nightly build as well.</p>
<p>Besides the BatchRendererBackend implementation you&#39;ll need to provide the size of the texture atlas as parameters. As mentioned above a 2k texture was enough to run all of Niftys standard examples.</p>
<p>So, that&#39;s all there is!</p>
<p>If you made it through this huge post. Congratulations! You now know all the things that took me a couple of months to figure out :)</p>
<p>I hope you&#39;ve enjoyed this in-depth explanation a bit!</p>
<p>See you next time!</p>
<p>void</p></p>



        </section>

        <aside id="sidebar">
          <a href="https://github.com/void256/nifty-gui/archive/gh-pages.zip" class="button">
            <small>Download</small>
            .zip file
          </a>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  </body>
</html>
